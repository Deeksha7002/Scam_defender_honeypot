import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import type { CaseFile, Message } from './types';

export class PDFGenerator {
    private static createPDFDoc(caseFile: CaseFile, transcript: Message[]): jsPDF {
        const doc = new jsPDF();

        // --- Header ---
        doc.setFillColor(220, 38, 38); // Red header
        doc.rect(0, 0, 210, 40, 'F');

        doc.setTextColor(255, 255, 255);
        doc.setFontSize(22);
        doc.setFont('helvetica', 'bold');
        doc.text("CONFIDENTIAL EVIDENCE REPORT", 105, 20, { align: "center" });

        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        doc.text("GENERATED BY HONEYPOT AI DEFENSE SYSTEM", 105, 30, { align: "center" });

        // --- Metadata ---
        doc.setTextColor(0, 0, 0);
        doc.setFontSize(12);
        doc.text(`Case ID: ${caseFile.id}`, 15, 55);
        doc.text(`Date: ${new Date().toLocaleDateString()}`, 15, 62);
        doc.text(`Scammer Name: ${caseFile.scammerName}`, 15, 69);
        doc.text(`Platform: ${caseFile.platform.toUpperCase()}`, 15, 76);

        if (caseFile.detectedLocation) {
            doc.text(`IP Address: ${caseFile.detectedLocation.ip}`, 15, 83);
            doc.text(`Source Origin: ${caseFile.detectedLocation.city}, ${caseFile.detectedLocation.country}`, 15, 90);
        }

        // Threat Level Badge
        doc.setFillColor(caseFile.threatLevel === 'scam' ? 220 : 255, 38, 38);
        doc.setDrawColor(0);
        doc.roundedRect(150, 50, 45, 15, 2, 2, 'FD');
        doc.setTextColor(255, 255, 255);
        doc.setFont('helvetica', 'bold');
        doc.text(caseFile.threatLevel.toUpperCase(), 172.5, 60, { align: 'center' });

        // --- IOCs Table ---
        doc.setTextColor(0, 0, 0);
        doc.setFontSize(14);

        let iocStartY = 95;
        if (caseFile.detectedLocation) {
            iocStartY = 105;
        }

        doc.text("Indicators of Compromise (IOCs)", 15, iocStartY);

        const iocData = [
            ...caseFile.iocs.urls.map(u => ['URL', u]),
            ...caseFile.iocs.paymentMethods.map(p => ['Payment/Wallet', p]),
            ...caseFile.iocs.domains.map(d => ['Domain', d])
        ];

        if (caseFile.detectedLocation?.financials) {
            const fin = caseFile.detectedLocation.financials;
            iocData.unshift(['FINANCIAL ID', `${fin.method}: ${fin.identifier} (${fin.institution})`]);
        }

        if (iocData.length === 0) {
            iocData.push(['None', 'No specific IOCs extracted']);
        }

        autoTable(doc, {
            startY: iocStartY + 5,
            head: [['Type', 'Value']],
            body: iocData,
            theme: 'grid',
            headStyles: { fillColor: [40, 40, 40] },
            styles: { fontSize: 10 }
        });

        // --- Transcript ---
        const finalY = (doc as any).lastAutoTable.finalY + 15;
        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        doc.text("Chat Transcript", 15, finalY);

        let yPos = finalY + 10;

        doc.setFontSize(10);
        doc.setFont('courier', 'normal'); // Monospace for logs

        transcript.forEach(msg => {
            if (yPos > 270) { // Reduced bottom margin for footer
                doc.addPage();
                this.addWatermark(doc);
                this.addFooter(doc, caseFile.id);
                yPos = 30; // Start lower on new pages to clear header if we had one (we don't repeat header but good practice)
            }

            const time = new Date(msg.timestamp).toLocaleTimeString();
            const sender = msg.sender === 'agent' ? "HONEYPOT_AI" : "SCAMMER";
            const prefix = `[${time}] ${sender}: `;

            doc.setFont('courier', 'bold');
            if (msg.sender === 'agent') {
                doc.setTextColor(22, 163, 74); // Green
            } else {
                doc.setTextColor(220, 38, 38); // Red
            }
            doc.text(prefix, 15, yPos);

            // Text wrapping for message content
            doc.setFont('courier', 'normal');
            doc.setTextColor(0, 0, 0);

            const splitText = doc.splitTextToSize(msg.content, 180);

            // Indent content slightly
            doc.text(splitText, 15, yPos + 5);

            yPos += (splitText.length * 5) + 10;
        });

        // Add features to the first page (and subsequent ones were handled in loop)
        // We set page 1 active to draw the watermark/barcode there
        const totalPages = doc.getNumberOfPages();
        for (let i = 1; i <= totalPages; i++) {
            doc.setPage(i);
            this.addWatermark(doc);
            this.addFooter(doc, caseFile.id);
        }

        // Draw Barcode on Page 1
        doc.setPage(1);
        this.addBarcode(doc, caseFile.id, 160, 25);

        return doc;
    }

    static generateCaseReport(caseFile: CaseFile, transcript: Message[]) {
        const doc = this.createPDFDoc(caseFile, transcript);
        doc.save(`Evidence_Report_${caseFile.id}.pdf`);
    }

    static getPDFBlob(caseFile: CaseFile, transcript: Message[]): Blob {
        const doc = this.createPDFDoc(caseFile, transcript);
        return doc.output('blob');
    }

    private static addWatermark(doc: jsPDF) {
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();

        doc.saveGraphicsState();
        doc.setTextColor(230, 230, 230); // Very light gray
        doc.setFontSize(60);
        doc.setFont('helvetica', 'bold');

        // Rotate text
        // jsPDF rotation is around a point. We put it in the center.
        doc.text("CONFIDENTIAL", pageWidth / 2, pageHeight / 2, {
            align: 'center',
            angle: 45
        });

        doc.restoreGraphicsState();
    }

    private static addFooter(doc: jsPDF, caseId: string) {
        const pageHeight = doc.internal.pageSize.getHeight();
        const pageWidth = doc.internal.pageSize.getWidth();

        doc.saveGraphicsState();

        // Line
        doc.setDrawColor(200, 200, 200);
        doc.line(10, pageHeight - 15, pageWidth - 10, pageHeight - 15);

        // Text
        doc.setFontSize(8);
        doc.setTextColor(100, 100, 100);
        doc.setFont('courier', 'normal');

        // Generate a fake hash for "Chain of Custody"
        const hash = "0x" + Array.from(caseId).map(c => c.charCodeAt(0).toString(16)).join('').padEnd(40, '0').slice(0, 40);

        doc.text(`CHAIN OF CUSTODY: ${hash.toUpperCase()}`, 15, pageHeight - 10);
        doc.text(`PAGE ${doc.getCurrentPageInfo().pageNumber}`, pageWidth - 25, pageHeight - 10);

        // Stamp
        doc.setFillColor(240, 240, 240);
        doc.setDrawColor(150, 150, 150);
        doc.roundedRect(pageWidth - 60, pageHeight - 25, 45, 12, 1, 1, 'FD');
        doc.setTextColor(0, 0, 150);
        doc.setFontSize(6);
        doc.text("DIGITALLY SIGNED\nSECURE ARCHIVE", pageWidth - 37.5, pageHeight - 20, { align: 'center' });

        doc.restoreGraphicsState();
    }

    private static addBarcode(doc: jsPDF, data: string, x: number, y: number) {
        // Simple simulated barcode (random widths based on char codes)
        doc.saveGraphicsState();
        doc.setFillColor(0, 0, 0);

        // Adjust starting X to be safer if data is long
        const startX = data.length > 20 ? x - 20 : x;
        let currentX = startX;
        const h = 10;
        const maxWidth = 200; // Page width margin

        for (let i = 0; i < data.length; i++) {
            if (currentX > maxWidth) break; // Prevent overflow
            const charCode = data.charCodeAt(i);
            const w = (charCode % 3) + 1; // Width 1-3
            doc.rect(currentX, y, w, h, 'F');
            currentX += w + 1; // Gap
        }

        // Add Label
        doc.setFontSize(8);
        doc.setFont('courier', 'normal');

        // Truncate text if super long to avoid mess
        const displaySafe = data.length > 25 ? data.substring(0, 22) + "..." : data;
        doc.text(displaySafe, startX, y + h + 3);

        doc.restoreGraphicsState();
    }

    static downloadJSON(caseFile: CaseFile, transcript: Message[]) {
        // Destructure to remove transcript from metadata (it is already passed as 2nd arg)
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { transcript: _t, ...metaWithoutTranscript } = caseFile;

        const data = {
            metadata: metaWithoutTranscript,
            transcript: transcript,
            generatedAt: new Date().toISOString()
        };

        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `Case_Data_${caseFile.id}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
}
